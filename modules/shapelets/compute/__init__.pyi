from typing import Optional, Tuple, Union, overload, Callable, Sequence
import numpy as np
import numpy.typing as npt
from . import _pygauss

ArrayLike = Union[ShapeletsArray,ParallelFor,npt.ArrayLike, np.ndarray]
Floating = Union[float,np.complex64, np.complex128]
Shape = Tuple[int, ...]
ShapeLike = Union[int, Sequence[int]]
DataTypeLike = npt.DTypeLike

class ParallelFor:
    def __iter__(self) -> ParallelFor: ...
    def __next__(self) -> ParallelFor: ...

class ShapeletsArray:
    def __add__(self, other: ArrayLike) -> ShapeletsArray: ...
    def __and__(self, other: ArrayLike) -> ShapeletsArray: ...
    def __copy__(self) -> ShapeletsArray: ...
    def __deepcopy__(self, memo: object) -> ShapeletsArray: ...
    def __eq__(self, other: ArrayLike) -> ShapeletsArray: ...
    def __ge__(self, other: ArrayLike) -> ShapeletsArray: ...
    def __getitem__(self, selector: object) -> ShapeletsArray: ...
    def __gt__(self, other: ArrayLike) -> ShapeletsArray: ...
    def __iadd__(self, other: ArrayLike) -> ShapeletsArray: ...
    def __iand__(self, other: ArrayLike) -> ShapeletsArray: ...
    def __ilshift__(self, other: ArrayLike) -> ShapeletsArray: ...
    def __imod__(self, other: ArrayLike) -> ShapeletsArray: ...
    def __imul__(self, other: ArrayLike) -> ShapeletsArray: ...
    def __ior__(self, other: ArrayLike) -> ShapeletsArray: ...
    def __ipow__(self, other: ArrayLike) -> ShapeletsArray: ...
    def __irshift__(self, other: ArrayLike) -> ShapeletsArray: ...
    def __isub__(self, other: ArrayLike) -> ShapeletsArray: ...
    def __itruediv__(self, other: ArrayLike) -> ShapeletsArray: ...
    def __ixor__(self, other: ArrayLike) -> ShapeletsArray: ...
    def __le__(self, other: ArrayLike) -> ShapeletsArray: ...
    def __lshift__(self, other: ArrayLike) -> ShapeletsArray: ...
    def __lt__(self, other: ArrayLike) -> ShapeletsArray: ...
    def __matmul__(self, other: ArrayLike) -> ShapeletsArray: ...
    def __mod__(self, other: ArrayLike) -> ShapeletsArray: ...
    def __mul__(self, other: ArrayLike) -> ShapeletsArray: ...
    def __ne__(self, other: ArrayLike) -> ShapeletsArray: ...
    def __neg__(self) -> ShapeletsArray: ...
    def __or__(self, other: ArrayLike) -> ShapeletsArray: ...
    def __pow__(self, other: ArrayLike) -> ShapeletsArray: ...
    def __radd__(self, other: ArrayLike) -> ShapeletsArray: ...
    def __rand__(self, other: ArrayLike) -> ShapeletsArray: ...
    def __repr__(self) -> str: ...
    def __rlshift__(self, other: ArrayLike) -> ShapeletsArray: ...
    def __rmatmul__(self, other: ArrayLike) -> ShapeletsArray: ...
    def __rmod__(self, other: ArrayLike) -> ShapeletsArray: ...
    def __rmul__(self, other: ArrayLike) -> ShapeletsArray: ...
    def __ror__(self, other: ArrayLike) -> ShapeletsArray: ...
    def __rpow__(self, other: ArrayLike) -> ShapeletsArray: ...
    def __rrshift__(self, other: ArrayLike) -> ShapeletsArray: ...
    def __rshift__(self, other: ArrayLike) -> ShapeletsArray: ...
    def __rsub__(self, other: ArrayLike) -> ShapeletsArray: ...
    def __rtruediv__(self, other: ArrayLike) -> ShapeletsArray: ...
    def __rxor__(self, other: ArrayLike) -> ShapeletsArray: ...
    def __setitem__(self, selector: object, value: ArrayLike) -> ShapeletsArray: ...
    def __sub__(self, other: ArrayLike) -> ShapeletsArray: ...
    def __truediv__(self, other: ArrayLike) -> ShapeletsArray: ...
    def __xor__(self, other: ArrayLike) -> ShapeletsArray: ...
    def astype(self, type: DataTypeLike) -> ShapeletsArray: ...
    def display(self, precision: int = 4) -> None: ...
    def same_as(self, arr_like: ArrayLike, eps: float = 0.0001) -> bool: ...
    @property
    def H(self) -> ShapeletsArray:...
    @property
    def T(self) -> ShapeletsArray:...
    @property
    def backend(self) -> Backend: ...
    @property
    def dtype(self) -> DataTypeLike: ...
    @property
    def is_column(self) -> bool: ...
    @property
    def is_row(self) -> bool: ...
    @property
    def is_single(self) -> bool: ...
    @property
    def is_vector(self) -> bool: ...
    @property
    def itemsize(self) -> int: ...
    @property
    def ndim(self) -> int: ...
    @property
    def shape(self) -> Shape: ...
    @property
    def size(self) -> int: ...
    __array_priority__ = 30
    __hash__ = None


class Backend:
    def __eq__(self, arg0: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __init__(self, arg0: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, arg0: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, arg0: int) -> None: ...
    @property
    def name(self) -> str:...
    CPU: shapelets.compute._pygauss.Backend # value = <Backend.CPU: 1>
    CUDA: _pygauss.Backend # value = <Backend.CUDA: 2>
    Default: _pygauss.Backend # value = <Backend.Default: 0>
    OpenCL: _pygauss.Backend # value = <Backend.OpenCL: 4>
    __members__: dict # value = {'Default': <Backend.Default: 0>, 'CPU': <Backend.CPU: 1>, 'CUDA': <Backend.CUDA: 2>, 'OpenCL': <Backend.OpenCL: 4>}


class BorderType:
    def __eq__(self, arg0: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __init__(self, arg0: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, arg0: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, arg0: int) -> None: ...
    @property
    def name(self) -> str:...
    ClampEdge: _pygauss.BorderType # value = <BorderType.ClampEdge: 2>
    Periodic: _pygauss.BorderType # value = <BorderType.Periodic: 3>
    Symmetric: _pygauss.BorderType # value = <BorderType.Symmetric: 1>
    Zero: _pygauss.BorderType # value = <BorderType.Zero: 0>
    __members__: dict # value = {'Zero': <BorderType.Zero: 0>, 'Symmetric': <BorderType.Symmetric: 1>, 'ClampEdge': <BorderType.ClampEdge: 2>, 'Periodic': <BorderType.Periodic: 3>}

class ConvDomain:
    def __eq__(self, arg0: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __init__(self, arg0: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, arg0: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, arg0: int) -> None: ...
    @property
    def name(self) -> str:...
    Auto: _pygauss.ConvDomain # value = <ConvDomain.Auto: 0>
    Frequency: _pygauss.ConvDomain # value = <ConvDomain.Frequency: 2>
    Spatial: _pygauss.ConvDomain # value = <ConvDomain.Spatial: 1>
    __members__: dict # value = {'Auto': <ConvDomain.Auto: 0>, 'Frequency': <ConvDomain.Frequency: 2>, 'Spatial': <ConvDomain.Spatial: 1>}

class ConvMode:
    def __eq__(self, arg0: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __init__(self, arg0: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, arg0: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, arg0: int) -> None: ...
    @property
    def name(self) -> str:...
    Default: _pygauss.ConvMode # value = <ConvMode.Default: 0>
    Expand: _pygauss.ConvMode # value = <ConvMode.Expand: 1>
    __members__: dict # value = {'Default': <ConvMode.Default: 0>, 'Expand': <ConvMode.Expand: 1>}

class DeviceInfo:
    def __repr__(self) -> str: ...
    @property
    def compute(self) -> str: ...
    @property
    def id(self) -> int: ...
    @property
    def isDoubleAvailable(self) -> bool: ...
    @property
    def isHalfAvailable(self) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def platform(self) -> str: ...

class DeviceMemory:
    def __repr__(self) -> str: ...
    @property
    def buffers(self) -> int: ...
    @property
    def bytes(self) -> int: ...
    @property
    def locked_buffers(self) -> int: ...
    @property
    def locked_bytes(self) -> int: ...

class MatrixProfile:
    def __init__(self, arg0: ShapeletsArray, arg1: ShapeletsArray) -> None: ...
    @property
    def index(self) -> ShapeletsArray: ...
    @index.setter
    def index(self, arg0: ShapeletsArray) -> None: ...
    @property
    def profile(self) -> ShapeletsArray: ...
    @profile.setter
    def profile(self, arg0: ShapeletsArray) -> None: ...

class MatrixProperties:
    def __eq__(self, arg0: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __init__(self, arg0: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, arg0: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, arg0: int) -> None: ...
    @property
    def name(self) -> str:...
    BlockDiagonal: _pygauss.MatrixProperties # value = <MatrixProperties.Symmetric: 512>
    Conjugated: _pygauss.MatrixProperties # value = <MatrixProperties.Conjugated: 4>
    ConjugatedTransposed: _pygauss.MatrixProperties # value = <MatrixProperties.ConjugatedTransposed: 2>
    Default: _pygauss.MatrixProperties # value = <MatrixProperties.Default: 0>
    Lower: _pygauss.MatrixProperties # value = <MatrixProperties.Lower: 64>
    Orthogonal: _pygauss.MatrixProperties # value = <MatrixProperties.Orthogonal: 2048>
    PositiveDefinite: _pygauss.MatrixProperties # value = <MatrixProperties.PositiveDefinite: 1024>
    Symmetric: _pygauss.MatrixProperties # value = <MatrixProperties.Symmetric: 512>
    Transposed: _pygauss.MatrixProperties # value = <MatrixProperties.Transposed: 1>
    TriDiagonal: _pygauss.MatrixProperties # value = <MatrixProperties.TriDiagonal: 4096>
    UnitDiagonal: _pygauss.MatrixProperties # value = <MatrixProperties.UnitDiagonal: 128>
    Upper: _pygauss.MatrixProperties # value = <MatrixProperties.Upper: 32>
    __members__: dict # value = {'Default': <MatrixProperties.Default: 0>, 'Transposed': <MatrixProperties.Transposed: 1>, 'ConjugatedTransposed': <MatrixProperties.ConjugatedTransposed: 2>, 'Conjugated': <MatrixProperties.Conjugated: 4>, 'Upper': <MatrixProperties.Upper: 32>, 'Lower': <MatrixProperties.Lower: 64>, 'UnitDiagonal': <MatrixProperties.UnitDiagonal: 128>, 'Symmetric': <MatrixProperties.Symmetric: 512>, 'PositiveDefinite': <MatrixProperties.PositiveDefinite: 1024>, 'Orthogonal': <MatrixProperties.Orthogonal: 2048>, 'TriDiagonal': <MatrixProperties.TriDiagonal: 4096>, 'BlockDiagonal': <MatrixProperties.Symmetric: 512>}

class NormType:
    def __eq__(self, arg0: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __init__(self, arg0: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, arg0: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, arg0: int) -> None: ...
    @property
    def name(self) -> str: ...
    Euclid: _pygauss.NormType # value = <NormType.Vector2: 2>
    LPQ: _pygauss.NormType # value = <NormType.LPQ: 7>
    Matrix: _pygauss.NormType # value = <NormType.Matrix: 4>
    MatrixInf: _pygauss.NormType # value = <NormType.MatrixInf: 5>
    Singular: _pygauss.NormType # value = <NormType.Singular: 6>
    Vector1: _pygauss.NormType # value = <NormType.Vector1: 0>
    Vector2: _pygauss.NormType # value = <NormType.Vector2: 2>
    VectorInf: _pygauss.NormType # value = <NormType.VectorInf: 1>
    VectorP: _pygauss.NormType # value = <NormType.VectorP: 3>
    __members__: dict # value = {'Vector1': <NormType.Vector1: 0>, 'VectorInf': <NormType.VectorInf: 1>, 'Vector2': <NormType.Vector2: 2>, 'VectorP': <NormType.VectorP: 3>, 'Matrix': <NormType.Matrix: 4>, 'MatrixInf': <NormType.MatrixInf: 5>, 'Singular': <NormType.Singular: 6>, 'LPQ': <NormType.LPQ: 7>, 'Euclid': <NormType.Vector2: 2>}

class ScanOp:
    def __eq__(self, arg0: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __init__(self, arg0: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, arg0: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, arg0: int) -> None: ...
    @property
    def name(self) -> str: ...
    Add: _pygauss.ScanOp # value = <ScanOp.Add: 0>
    Max: _pygauss.ScanOp # value = <ScanOp.Max: 3>
    Min: _pygauss.ScanOp # value = <ScanOp.Min: 2>
    Mul: _pygauss.ScanOp # value = <ScanOp.Mul: 1>
    __members__: dict # value = {'Add': <ScanOp.Add: 0>, 'Mul': <ScanOp.Mul: 1>, 'Min': <ScanOp.Min: 2>, 'Max': <ScanOp.Max: 3>}

class ScopedBatch:
    def __enter__(self) -> None: ...
    def __exit__(self, *args) -> None: ...


def absolute(array_like: ArrayLike) -> ShapeletsArray:
    """
    Adding comments for the sake of it
    """

def add(left: ArrayLike, right: ArrayLike) -> ShapeletsArray:...
def all(array_like: ArrayLike, dim: Optional[int] = None) -> Union[bool, ShapeletsArray]:...
def amax(array_like: ArrayLike, dim: Optional[int] = None) -> Union[float, complex, ShapeletsArray]:...
def amin(array_like: ArrayLike, dim: Optional[int] = None) -> Union[float, complex, ShapeletsArray]:...
def angle(array_like: ArrayLike) -> ShapeletsArray:...
def angle_deg(array_like: ArrayLike) -> ShapeletsArray:...
def any(array_like: ArrayLike, dim: Optional[int] = None) -> Union[bool, ShapeletsArray]:...
def arccos(array_like: ArrayLike) -> ShapeletsArray: ...
def arccosh(array_like: ArrayLike) -> ShapeletsArray:...
def arcsin(array_like: ArrayLike) -> ShapeletsArray:...
def arcsinh(array_like: ArrayLike) -> ShapeletsArray:...
def arctan(array_like: ArrayLike) -> ShapeletsArray:...
def arctan2(left: ArrayLike, right: ArrayLike) -> ShapeletsArray:...
def arctanh(array_like: ArrayLike) -> ShapeletsArray:...
def argmax(array_like: ArrayLike, dim: Optional[int] = None) -> Union[Tuple[int, float], Tuple[int, complex], Tuple[ShapeletsArray, ShapeletsArray]]:...
def argmin(array_like: ArrayLike, dim: Optional[int] = None) -> Union[Tuple[int, float], Tuple[int, complex], Tuple[ShapeletsArray, ShapeletsArray]]:...
def array(array_like: ArrayLike, shape: Optional[ShapeLike] = None, dtype: Optional[DataTypeLike] = None) -> ShapeletsArray:...
@overload
def batch() -> ScopedBatch: ...
@overload
def batch(arg0: Callable[[], ShapeletsArray] ) -> ShapeletsArray: ...
def bitwise_and(left: ArrayLike, right: ArrayLike) -> ShapeletsArray:...
def bitwise_or(left: ArrayLike, right: ArrayLike) -> ShapeletsArray:...
def bitwise_xor(left: ArrayLike, right: ArrayLike) -> ShapeletsArray:...
def cast(array_like: ArrayLike, dtype: DataTypeLike) -> ShapeletsArray:...
def cbrt(array_like: ArrayLike) -> ShapeletsArray:...
def ceil(array_like: ArrayLike) -> ShapeletsArray:...
def cholesky(array_like: ArrayLike, is_upper: bool = True) -> ShapeletsArray:...
def clip(array_like: ArrayLike, lo: ArrayLike = None, up: ArrayLike = None) -> ShapeletsArray: ...
@overload
def complex(array_like: ArrayLike) -> ShapeletsArray:...
@overload
def complex(left: ArrayLike, right: ArrayLike) -> ShapeletsArray: ...
def conj(array_like: ArrayLike) -> ShapeletsArray:...
def conjugate(array_like: ArrayLike) -> ShapeletsArray:...
def convolve(signal: ArrayLike, filter: ArrayLike, mode: ConvMode = ConvMode.Default, domain: ConvDomain = ConvDomain.Auto) -> ShapeletsArray:...
def convolve1(signal: ArrayLike, filter: ArrayLike, mode: ConvMode = ConvMode.Default, domain: ConvDomain = ConvDomain.Auto) -> ShapeletsArray:...
def convolve2(signal: ArrayLike, filter: ArrayLike, mode: ConvMode = ConvMode.Default, domain: ConvDomain = ConvDomain.Auto) -> ShapeletsArray:...
def convolve3(signal: ArrayLike, filter: ArrayLike, mode: ConvMode = ConvMode.Default, domain: ConvDomain = ConvDomain.Auto) -> ShapeletsArray:...
def corrcoef(a: ShapeletsArray, b: ShapeletsArray) -> Union[float, complex]:...
def cos(array_like: ArrayLike) -> ShapeletsArray:...
def cosh(array_like: ArrayLike) -> ShapeletsArray:...
def count_nonzero(array_like: ArrayLike, dim: Optional[int] = None) -> Union[float, complex, ShapeletsArray]:...
def covp(a: ShapeletsArray, b: ShapeletsArray) -> ShapeletsArray:...
def covs(a: ShapeletsArray, b: ShapeletsArray) -> ShapeletsArray:...
def cumprod(array_like: ArrayLike, dim: int = 0) -> Union[float, complex, ShapeletsArray]:...
def cumsum(array_like: ArrayLike, dim: int = 0) -> Union[float, complex, ShapeletsArray]:...
def deg2rad(array_like: ArrayLike) -> ShapeletsArray:...
def degrees(array_like: ArrayLike) -> ShapeletsArray:...
def det(array_like: ArrayLike) -> Floating:...
def device_gc() -> None:...
def diag(a: ShapeletsArray, index: int = 0, extract: bool = False) -> ShapeletsArray: ...
def diff1(array_like: ArrayLike, dim: int) -> ShapeletsArray:...
def diff2(array_like: ArrayLike, dim: int) -> ShapeletsArray:...
def divide(left: ArrayLike, right: ArrayLike) -> ShapeletsArray:...
def dot(lhs: ArrayLike, rhs: ArrayLike, conj_lhs: bool = False, conj_rhs: bool = False) -> ShapeletsArray:...
def dot_scalar(lhs: ArrayLike, rhs: ArrayLike, conj_lhs: bool = False, conj_rhs: bool = False) -> Union[float, complex]:...
def empty(shape: ShapeLike, dtype: DataTypeLike = 'float32') -> ShapeletsArray: ...
def enable_manual_eval(new_value: bool) -> None:...
def equal(left: ArrayLike, right: ArrayLike) -> ShapeletsArray:...
def erf(array_like: ArrayLike) -> ShapeletsArray:...
def erfc(array_like: ArrayLike) -> ShapeletsArray:...
def eval(*args) -> None:...
def exp(array_like: ArrayLike) -> ShapeletsArray:...
def exp2(array_like: ArrayLike) -> ShapeletsArray:...
def expm1(array_like: ArrayLike) -> ShapeletsArray:...
def eye(N: int, M: Optional[int] = None, k: int = 0, dtype: DataTypeLike = 'float32') -> ShapeletsArray:...
def fabs(array_like: ArrayLike) -> ShapeletsArray: ...
def factorial(array_like: ArrayLike) -> ShapeletsArray:...
def fft(signal: ArrayLike, odim: Optional[int] = 0, norm: Optional[float] = None) -> ShapeletsArray:...
def fix(array_like: ArrayLike) -> ShapeletsArray:...
def flat(array_like: ArrayLike) -> ShapeletsArray:...
def flatnonzero(array_like: ArrayLike) -> ShapeletsArray:...
def flip(array_like: ArrayLike, dimension: int = 0) -> ShapeletsArray:...
def floor(array_like: ArrayLike) -> ShapeletsArray:...
def floor_divide(left: ArrayLike, right: ArrayLike) -> ShapeletsArray:...
def fmin(left: ArrayLike, right: ArrayLike) -> ShapeletsArray:...
def full(shape: ShapeLike, fill_value: ArrayLike, dtype: DataTypeLike = 'float32') -> ShapeletsArray:...
def gemm(a: ArrayLike, b: ArrayLike, c: Optional[ArrayLike] = None, alpha: float = 1.0, beta: float = 0.0, transA: bool = False, transB: bool = False) -> ShapeletsArray:...
def get_available_backends() -> Sequence[Backend]:...
def get_backend() -> Backend:...
def get_device() -> DeviceInfo:...
def get_device_memory(dev: Optional[Union[int, DeviceInfo]] = None) -> DeviceMemory:...
def get_devices() -> Sequence[DeviceInfo]:...
def greater(left: ArrayLike, right: ArrayLike) -> ShapeletsArray:...
def greater_equal(left: ArrayLike, right: ArrayLike) -> ShapeletsArray:...
def has_backend(test_backend: Backend) -> int:...
def hypot(left: ArrayLike, right: ArrayLike) -> ShapeletsArray:...
def identity(shape: Shape, dtype: DataTypeLike = 'float32') -> ShapeletsArray:...
def ifft(coeff: ArrayLike, odim: Optional[int] = 0, norm: Optional[float] = None) -> ShapeletsArray:...
def imag(array_like: ArrayLike) -> ShapeletsArray:...
def intersect(x1: ArrayLike, x2: ArrayLike, is_unique: bool = False) -> ShapeletsArray:...
def inverse(array_like: ArrayLike, options: MatrixProperties = MatrixProperties.Default) -> ShapeletsArray:...
def iota(shape: ShapeLike, tile: Shape = (1, 1), dtype: DataTypeLike = 'float32') -> ShapeletsArray:...
def iscomplex(array_like: ArrayLike) -> ShapeletsArray:...
def isfinite(array_like: ArrayLike) -> ShapeletsArray:...
def isinf(array_like: ArrayLike) -> ShapeletsArray:...
def isnan(array_like: ArrayLike) -> ShapeletsArray:...
def isreal(array_like: ArrayLike) -> ShapeletsArray:...
def join(lst: list, dimension: int = 0) -> ShapeletsArray:...
def left_shift(left: ArrayLike, right: ArrayLike) -> ShapeletsArray:...
def less(left: ArrayLike, right: ArrayLike) -> ShapeletsArray:...
def less_equal(left: ArrayLike, right: ArrayLike) -> ShapeletsArray:...
def lgamma(array_like: ArrayLike) -> ShapeletsArray:...
def log(array_like: ArrayLike) -> ShapeletsArray:...
def log10(array_like: ArrayLike) -> ShapeletsArray:...
def log1p(array_like: ArrayLike) -> ShapeletsArray:...
def log2(array_like: ArrayLike) -> ShapeletsArray:...
def logical_and(left: ArrayLike, right: ArrayLike) -> ShapeletsArray:...
def logical_not(array_like: ArrayLike) -> ShapeletsArray:...
def logical_or(left: ArrayLike, right: ArrayLike) -> ShapeletsArray:...
def lower(array_like: ArrayLike, unit_diag: bool = False) -> ShapeletsArray:...
def lu(array_like: ArrayLike) -> tuple: ...
def manual_eval_enabled() -> bool:...
def matmul(lhs: ArrayLike, rhs: ArrayLike, lhs_options: MatrixProperties = MatrixProperties.Default, rhs_options: MatrixProperties = MatrixProperties.Default) -> ShapeletsArray:...
def matmulNT(lhs: ArrayLike, rhs: ArrayLike) -> ShapeletsArray:...
def matmulTN(lhs: ArrayLike, rhs: ArrayLike) -> ShapeletsArray:...
def matmulTT(lhs: ArrayLike, rhs: ArrayLike) -> ShapeletsArray:...
def matmul_chain(*args) -> ShapeletsArray:...
def matrixprofile(ta: ShapeletsArray, m: int, tb: Optional[ShapeletsArray] = None) -> MatrixProfile:...
def matrixprofileLR(ta: ShapeletsArray, m: int) -> dict:...
def maximum(left: ArrayLike, right: ArrayLike) -> ShapeletsArray:...
def mean(a: ShapeletsArray, weights: Optional[ShapeletsArray] = None, dim: Optional[int] = None) -> Union[float, complex, ShapeletsArray]:...
def median(a: ShapeletsArray, dim: Optional[int] = None) -> Union[float, complex, ShapeletsArray]:...
def minimum(left: ArrayLike, right: ArrayLike) -> ShapeletsArray:...
def mod(left: ArrayLike, right: ArrayLike) -> ShapeletsArray:...
def moddims(array_like: ArrayLike, shape: Shape) -> ShapeletsArray:...
def multiply(left: ArrayLike, right: ArrayLike) -> ShapeletsArray:...
def nan_to_num(array_like: ArrayLike, nan: float = 0.0, inf: float = 0.0) -> ShapeletsArray:...
def nanargmax(array_like: ArrayLike, dim: Optional[int] = None) -> Union[Tuple[int, float], Tuple[int, complex], Tuple[ShapeletsArray, ShapeletsArray]]:...
def nanargmin(array_like: ArrayLike, dim: Optional[int] = None) -> Union[Tuple[int, float], Tuple[int, complex], Tuple[ShapeletsArray, ShapeletsArray]]:...
def nancumprod(array_like: ArrayLike, dim: int = 0) -> Union[float, complex, ShapeletsArray]:...
def nancumsum(array_like: ArrayLike, dim: int = 0) -> Union[float, complex, ShapeletsArray]:...
def nanmax(array_like: ArrayLike, dim: Optional[int] = None) -> Union[float, complex, ShapeletsArray]:...
def nanmin(array_like: ArrayLike, dim: Optional[int] = None) -> Union[float, complex, ShapeletsArray]:...
def nanscan(array_like: ArrayLike, dim: int = 0, nan: float = 0.0, op: ScanOp = ScanOp.Add, inclusive_scan: bool = True) -> ShapeletsArray:...
def negative(array_like: ArrayLike) -> ShapeletsArray:...
def norm(array_like: ArrayLike, type: NormType = NormType.Vector2, p: float = 1.0, q: float = 1.0) -> float: ...
def not_equal(left: ArrayLike, right: ArrayLike) -> ShapeletsArray:...
def ones(shape: ShapeLike, dtype: DataTypeLike = 'float32') -> ShapeletsArray:...
def pad(array_like: ArrayLike, begin: Shape, end: Shape, fill_type: BorderType) -> ShapeletsArray:...
def parallel_range(arg: Union[int, slice]) -> ParallelFor: ...
def pinverse(array_like: ArrayLike, tol: float = 1e-06) -> ShapeletsArray: ...
def positive(array_like: ArrayLike) -> ShapeletsArray:...
def power(left: ArrayLike, right: ArrayLike) -> ShapeletsArray:...
def product(array_like: ArrayLike, dim: Optional[int] = None, nan_value: Optional[float] = None) -> Union[float, complex, ShapeletsArray]:...
def qr(array_like: ArrayLike) -> tuple: ...
def rad2deg(array_like: ArrayLike) -> ShapeletsArray:...
def radians(array_like: ArrayLike) -> ShapeletsArray:...
def range(shape: Shape, seq_dim: int = -1, dtype: DataTypeLike = 'float32') -> ShapeletsArray:...
def rank(array_like: ArrayLike, tol: float = 1e-05) -> int: ...
def real(array_like: ArrayLike) -> ShapeletsArray:...
def reciprocal(array_like: ArrayLike) -> ShapeletsArray:...
def rem(left: ArrayLike, right: ArrayLike) -> ShapeletsArray:...
def reorder(array_like: ArrayLike, x: int, y: int = 1, z: int = 2, w: int = 3) -> ShapeletsArray:...
def right_shift(left: ArrayLike, right: ArrayLike) -> ShapeletsArray:...
def rint(array_like: ArrayLike) -> ShapeletsArray:...
def root(left: ArrayLike, right: ArrayLike) -> ShapeletsArray:...
def round(array_like: ArrayLike, decimals: int = 0, *) -> ShapeletsArray:...
def rsqrt(array_like: ArrayLike) -> ShapeletsArray:...
def scan(array_like: ArrayLike, dim: int = 0, op: ScanOp = ScanOp.Add, inclusive_scan: bool = True) -> ShapeletsArray:...
def set_backend(arg0: Backend) -> None:...
def set_device(arg0: Union[int, DeviceInfo]) -> bool:...
def shift(array_like: ArrayLike, x: int, y: int = 0, z: int = 0, w: int = 0) -> ShapeletsArray:...
def sigmoid(array_like: ArrayLike) -> ShapeletsArray:...
def sign(array_like: ArrayLike) -> ShapeletsArray:...
def signbit(array_like: ArrayLike) -> ShapeletsArray:...
def sin(array_like: ArrayLike) -> ShapeletsArray:...
def sinh(array_like: ArrayLike) -> ShapeletsArray:...
def sort(array_like: ArrayLike, dim: int = 0, asc: bool = True) -> Tuple[ShapeletsArray, ShapeletsArray]:...
def sort_keys(data: ArrayLike, keys: ArrayLike, dim: int = 0, asc: bool = True) -> Tuple[ShapeletsArray, ShapeletsArray]:...
def sqrt(array_like: ArrayLike) -> ShapeletsArray:...
def square(array_like: ArrayLike) -> ShapeletsArray: ...
def stdev(a: ShapeletsArray, dim: Optional[int] = None) -> Union[float, complex, ShapeletsArray]: ...
def substract(left: ArrayLike, right: ArrayLike) -> ShapeletsArray:...
def sum(array_like: ArrayLike, dim: Optional[int] = None, nan_value: Optional[float] = None) -> Union[float, complex, ShapeletsArray]:...
def svd(array_like: ArrayLike) -> tuple: ...
def sync(dev: Optional[Union[int, DeviceInfo]] = None) -> None:...
def tan(array_like: ArrayLike) -> ShapeletsArray:...
def tanh(array_like: ArrayLike) -> ShapeletsArray: ...
def tgamma(array_like: ArrayLike) -> ShapeletsArray:...
@overload
def tile(array_like: ArrayLike, dims: Shape) -> ShapeletsArray:...
@overload
def tile(array_like: ArrayLike, x: int, y: int = 1, z: int = 1, w: int = 1) -> ShapeletsArray: ...
def topk_max(a: ShapeletsArray, k: int) -> tuple:...
def topk_min(a: ShapeletsArray, k: int) -> tuple:...
def transpose(array_like: ArrayLike, dims: bool = False) -> ShapeletsArray:...
def true_divide(left: ArrayLike, right: ArrayLike) -> ShapeletsArray:...
def trunc(array_like: ArrayLike) -> ShapeletsArray:...
def union(x1: ArrayLike, x2: ArrayLike, is_unique: bool = False) -> ShapeletsArray:...
def unique(array_like: ArrayLike, is_sorted: bool = False) -> ShapeletsArray:...
def upper(array_like: ArrayLike, unit_diag: bool = False) -> ShapeletsArray:...
def var_p(a: ShapeletsArray, weights: Optional[ShapeletsArray] = None, dim: Optional[int] = None) -> Union[float, complex, ShapeletsArray]: ...
def var_s(a: ShapeletsArray, weights: Optional[ShapeletsArray] = None, dim: Optional[int] = None) -> Union[float, complex, ShapeletsArray]: ...
def where(condition: ArrayLike, x: ArrayLike = None, y: ArrayLike = None) -> ShapeletsArray:...
def zeros(shape: ShapeLike, dtype: DataTypeLike = 'float32') -> ShapeletsArray:...

