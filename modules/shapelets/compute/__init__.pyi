from typing import Optional, Tuple, Union, overload, Callable
from .__base import Shape, ArrayLike, DataType, Number

def absolute(array_like: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def add(left: ArrayLike, right: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def all(array_like: ArrayLike, dim: Optional[int] = None) -> Union[bool, ShapeletsArray]:...
def amax(array_like: ArrayLike, dim: Optional[int] = None) -> Union[float, complex, ShapeletsArray]:...
def amin(array_like: ArrayLike, dim: Optional[int] = None) -> Union[float, complex, ShapeletsArray]:...
def angle(array_like: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def angle_deg(array_like: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def any(array_like: ArrayLike, dim: Optional[int] = None) -> Union[bool, ShapeletsArray]:...
def arccos(array_like: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray: ...
def arccosh(array_like: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def arcsin(array_like: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def arcsinh(array_like: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def arctan(array_like: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def arctan2(left: ArrayLike, right: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def arctanh(array_like: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def argmax(array_like: ArrayLike, dim: Optional[int] = None) -> Union[Tuple[int, float], Tuple[int, complex], Tuple[ShapeletsArray, ShapeletsArray]]:...
def argmin(array_like: ArrayLike, dim: Optional[int] = None) -> Union[Tuple[int, float], Tuple[int, complex], Tuple[ShapeletsArray, ShapeletsArray]]:...
def array(array_like: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
@overload
def batch() -> ScopedBatch: ...
@overload
def batch(arg0: Callable[[], ShapeletsArray] ) -> ShapeletsArray: ...
def bitwise_and(left: ArrayLike, right: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def bitwise_or(left: ArrayLike, right: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def bitwise_xor(left: ArrayLike, right: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def cast(array_like: ArrayLike, dtype: DataType) -> ShapeletsArray:...
def cbrt(array_like: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def ceil(array_like: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def cholesky(array_like: ArrayLike, is_upper: bool = True) -> ShapeletsArray:...
def clip(array_like: ArrayLike, lo: ArrayLike = None, up: ArrayLike = None, *, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray: ...
@overload
def complex(array_like: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
@overload
def complex(left: ArrayLike, right: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray: ...
def conj(array_like: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def conjugate(array_like: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def convolve(signal: ArrayLike, filter: ArrayLike, mode: ConvMode = ConvMode.Default, domain: ConvDomain = ConvDomain.Auto) -> ShapeletsArray:...
def convolve1(signal: ArrayLike, filter: ArrayLike, mode: ConvMode = ConvMode.Default, domain: ConvDomain = ConvDomain.Auto) -> ShapeletsArray:...
def convolve2(signal: ArrayLike, filter: ArrayLike, mode: ConvMode = ConvMode.Default, domain: ConvDomain = ConvDomain.Auto) -> ShapeletsArray:...
def convolve3(signal: ArrayLike, filter: ArrayLike, mode: ConvMode = ConvMode.Default, domain: ConvDomain = ConvDomain.Auto) -> ShapeletsArray:...
def corrcoef(a: ShapeletsArray, b: ShapeletsArray) -> Union[float, complex]:...
def cos(array_like: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def cosh(array_like: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def count_nonzero(array_like: ArrayLike, dim: Optional[int] = None) -> Union[float, complex, ShapeletsArray]:...
def covp(a: ShapeletsArray, b: ShapeletsArray) -> ShapeletsArray:...
def covs(a: ShapeletsArray, b: ShapeletsArray) -> ShapeletsArray:...
def cumprod(array_like: ArrayLike, dim: int = 0) -> Union[float, complex, ShapeletsArray]:...
def cumsum(array_like: ArrayLike, dim: int = 0) -> Union[float, complex, ShapeletsArray]:...
def deg2rad(array_like: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def degrees(array_like: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def det(array_like: ArrayLike) -> Union[float_, complex]:...
def device_gc() -> None:...
def diag(a: ShapeletsArray, index: int = 0, extract: bool = False) -> ShapeletsArray: ...
def diff1(array_like: ArrayLike, dim: int) -> ShapeletsArray:...
def diff2(array_like: ArrayLike, dim: int) -> ShapeletsArray:...
def divide(left: ArrayLike, right: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def dot(lhs: ArrayLike, rhs: ArrayLike, conj_lhs: bool = False, conj_rhs: bool = False) -> ShapeletsArray:...
def dot_scalar(lhs: ArrayLike, rhs: ArrayLike, conj_lhs: bool = False, conj_rhs: bool = False) -> Union[float, complex]:...
def empty(shape: Shape, dtype: DataType = 'float32') -> ShapeletsArray: ...
def enable_manual_eval(new_value: bool) -> None:...
def equal(left: ArrayLike, right: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def erf(array_like: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def erfc(array_like: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def eval(*args) -> None:...
def exp(array_like: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def exp2(array_like: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def expm1(array_like: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def eye(N: int, M: Optional[int] = None, k: int = 0, dtype: DataType = 'float32') -> ShapeletsArray:...
def fabs(array_like: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray: ...
def factorial(array_like: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def fft(signal: ArrayLike, odim: Optional[int] = 0, norm: Optional[float_] = None) -> ShapeletsArray:...
def fix(array_like: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def flat(array_like: ArrayLike) -> ShapeletsArray:...
def flatnonzero(array_like: ArrayLike) -> ShapeletsArray:...
def flip(array_like: ArrayLike, dimension: int = 0) -> ShapeletsArray:...
def floor(array_like: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def floor_divide(left: ArrayLike, right: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def fmin(left: ArrayLike, right: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def full(shape: Shape, fill_value: ArrayLike, dtype: DataType = 'float32') -> ShapeletsArray:...
def gemm(a: ArrayLike, b: ArrayLike, c: Optional[ArrayLike] = None, alpha: float_ = 1.0, beta: float_ = 0.0, transA: bool = False, transB: bool = False) -> ShapeletsArray:...
def get_available_backends() -> List[Backend]:...
def get_backend() -> Backend:...
def get_device() -> DeviceInfo:...
def get_device_memory(dev: Optional[Union[int, DeviceInfo]] = None) -> DeviceMemory:...
def get_devices() -> List[DeviceInfo]:...
def greater(left: ArrayLike, right: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def greater_equal(left: ArrayLike, right: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def has_backend(test_backend: Backend) -> int:...
def hypot(left: ArrayLike, right: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def identity(shape: Shape, dtype: DataType = 'float32') -> ShapeletsArray:...
def ifft(coeff: ArrayLike, odim: Optional[int] = 0, norm: Optional[float_] = None) -> ShapeletsArray:...
def imag(array_like: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def intersect(x1: ArrayLike, x2: ArrayLike, is_unique: bool = False) -> ShapeletsArray:...
def inverse(array_like: ArrayLike, options: MatrixProperties = MatrixProperties.Default) -> ShapeletsArray:...
def iota(shape: Shape, tile: Shape = (1, 1), dtype: DataType = 'float32') -> ShapeletsArray:...
def iscomplex(array_like: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def isfinite(array_like: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def isinf(array_like: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def isnan(array_like: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def isreal(array_like: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def join(lst: list, dimension: int = 0, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def left_shift(left: ArrayLike, right: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def less(left: ArrayLike, right: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def less_equal(left: ArrayLike, right: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def lgamma(array_like: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def log(array_like: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def log10(array_like: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def log1p(array_like: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def log2(array_like: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def logical_and(left: ArrayLike, right: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def logical_not(array_like: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def logical_or(left: ArrayLike, right: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def lower(array_like: ArrayLike, unit_diag: bool = False) -> ShapeletsArray:...
def lu(array_like: ArrayLike) -> tuple: ...
def manual_eval_enabled() -> bool:...
def matmul(lhs: ArrayLike, rhs: ArrayLike, lhs_options: MatrixProperties = MatrixProperties.Default, rhs_options: MatrixProperties = MatrixProperties.Default) -> ShapeletsArray:...
def matmulNT(lhs: ArrayLike, rhs: ArrayLike) -> ShapeletsArray:...
def matmulTN(lhs: ArrayLike, rhs: ArrayLike) -> ShapeletsArray:...
def matmulTT(lhs: ArrayLike, rhs: ArrayLike) -> ShapeletsArray:...
def matmul_chain(*args) -> ShapeletsArray:...
def matrixprofile(ta: ShapeletsArray, m: int, tb: Optional[ShapeletsArray] = None) -> MatrixProfile:...
def matrixprofileLR(ta: ShapeletsArray, m: int) -> dict:...
def maximum(left: ArrayLike, right: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def mean(a: ShapeletsArray, weights: Optional[ShapeletsArray] = None, dim: Optional[int] = None) -> Union[float, complex, ShapeletsArray]:...
def median(a: ShapeletsArray, dim: Optional[int] = None) -> Union[float, complex, ShapeletsArray]:...
def minimum(left: ArrayLike, right: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def mod(left: ArrayLike, right: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def moddims(array_like: ArrayLike, shape: Shape) -> ShapeletsArray:...
def multiply(left: ArrayLike, right: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def nan_to_num(array_like: ArrayLike, nan: float = 0.0, inf: float = 0.0) -> ShapeletsArray:...
def nanargmax(array_like: ArrayLike, dim: Optional[int] = None) -> Union[Tuple[int, float], Tuple[int, complex], Tuple[ShapeletsArray, ShapeletsArray]]:...
def nanargmin(array_like: ArrayLike, dim: Optional[int] = None) -> Union[Tuple[int, float], Tuple[int, complex], Tuple[ShapeletsArray, ShapeletsArray]]:...
def nancumprod(array_like: ArrayLike, dim: int = 0) -> Union[float, complex, ShapeletsArray]:...
def nancumsum(array_like: ArrayLike, dim: int = 0) -> Union[float, complex, ShapeletsArray]:...
def nanmax(array_like: ArrayLike, dim: Optional[int] = None) -> Union[float, complex, ShapeletsArray]:...
def nanmin(array_like: ArrayLike, dim: Optional[int] = None) -> Union[float, complex, ShapeletsArray]:...
def nanscan(array_like: ArrayLike, dim: int = 0, nan: float = 0.0, op: ScanOp = ScanOp.Add, inclusive_scan: bool = True) -> ShapeletsArray:...
def negative(array_like: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def norm(array_like: ArrayLike, type: NormType = NormType.Vector2, p: float = 1.0, q: float = 1.0) -> float: ...
def not_equal(left: ArrayLike, right: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def ones(shape: Shape, dtype: DataType = 'float32') -> ShapeletsArray:...
def pad(array_like: ArrayLike, begin: Shape, end: Shape, fill_type: BorderType) -> ShapeletsArray:...
def parallel_range(arg: Union[int, slice]) -> ParallelFor: ...
def pinverse(array_like: ArrayLike, tol: float = 1e-06) -> ShapeletsArray: ...
def positive(array_like: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def power(left: ArrayLike, right: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def product(array_like: ArrayLike, dim: Optional[int] = None, nan_value: Optional[float] = None) -> Union[float, complex, ShapeletsArray]:...
def qr(array_like: ArrayLike) -> tuple: ...
def rad2deg(array_like: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def radians(array_like: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def range(shape: Shape, seq_dim: int = -1, dtype: DataType = 'float32') -> ShapeletsArray:...
def rank(array_like: ArrayLike, tol: float = 1e-05) -> int: ...
def real(array_like: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def reciprocal(array_like: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def rem(left: ArrayLike, right: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def reorder(array_like: ArrayLike, x: int, y: int = 1, z: int = 2, w: int = 3) -> ShapeletsArray:...
def right_shift(left: ArrayLike, right: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def rint(array_like: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def root(left: ArrayLike, right: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def round(array_like: ArrayLike, decimals: int = 0, *, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def rsqrt(array_like: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def scan(array_like: ArrayLike, dim: int = 0, op: ScanOp = ScanOp.Add, inclusive_scan: bool = True) -> ShapeletsArray:...
def set_backend(arg0: Backend) -> None:...
def set_device(arg0: Union[int, DeviceInfo]) -> bool:...
def shift(array_like: ArrayLike, x: int, y: int = 0, z: int = 0, w: int = 0) -> ShapeletsArray:...
def sigmoid(array_like: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def sign(array_like: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def signbit(array_like: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def sin(array_like: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def sinh(array_like: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def sort(array_like: ArrayLike, dim: int = 0, asc: bool = True) -> Tuple[ShapeletsArray, ShapeletsArray]:...
def sort_keys(data: ArrayLike, keys: ArrayLike, dim: int = 0, asc: bool = True) -> Tuple[ShapeletsArray, ShapeletsArray]:...
def sqrt(array_like: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def square(array_like: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray: ...
def stdev(a: ShapeletsArray, dim: Optional[int] = None) -> Union[float, complex, ShapeletsArray]: ...
def substract(left: ArrayLike, right: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def sum(array_like: ArrayLike, dim: Optional[int] = None, nan_value: Optional[float] = None) -> Union[float, complex, ShapeletsArray]:...
def svd(array_like: ArrayLike) -> tuple: ...
def sync(dev: Optional[Union[int, DeviceInfo]] = None) -> None:...
def tan(array_like: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def tanh(array_like: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray: ...
def tgamma(array_like: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
@overload
def tile(array_like: ArrayLike, dims: Shape) -> ShapeletsArray:...
@overload
def tile(array_like: ArrayLike, x: int, y: int = 1, z: int = 1, w: int = 1) -> ShapeletsArray: ...
def topk_max(a: ShapeletsArray, k: int) -> tuple:...
def topk_min(a: ShapeletsArray, k: int) -> tuple:...
@overload
def transpose(array_like: ArrayLike, dims: bool = False) -> ShapeletsArray:...
@overload
def transpose(array_like: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray: ...
def true_divide(left: ArrayLike, right: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def trunc(array_like: ArrayLike, shape: Optional[Shape] = None, dtype: Optional[DataType] = None) -> ShapeletsArray:...
def union(x1: ArrayLike, x2: ArrayLike, is_unique: bool = False) -> ShapeletsArray:...
def unique(array_like: ArrayLike, is_sorted: bool = False) -> ShapeletsArray:...
def upper(array_like: ArrayLike, unit_diag: bool = False) -> ShapeletsArray:...
def var_p(a: ShapeletsArray, weights: Optional[ShapeletsArray] = None, dim: Optional[int] = None) -> Union[float, complex, ShapeletsArray]: ...
def var_s(a: ShapeletsArray, weights: Optional[ShapeletsArray] = None, dim: Optional[int] = None) -> Union[float, complex, ShapeletsArray]: ...
def where(condition: ArrayLike, x: ArrayLike = None, y: ArrayLike = None) -> ShapeletsArray:...
def zeros(shape: Shape, dtype: DataType = 'float32') -> ShapeletsArray:...
